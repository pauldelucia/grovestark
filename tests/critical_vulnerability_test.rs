use grovestark::ed25519_helpers::create_witness_from_platform_proofs;
use grovestark::utils::TestUtils;
/// CRITICAL VULNERABILITY TEST
/// This test reproduces the security vulnerability where a proof with
/// mismatched owner/identity IDs passes verification
use grovestark::*;

#[test]
fn test_critical_diff_vulnerability() {
    println!("\n=== CRITICAL VULNERABILITY TEST ===");
    println!("Testing if mismatched IDs can pass verification");
    println!("Using REAL data from the vulnerability scenario");

    // Use the EXACT data from the logs
    // Document owner: J846nouwbX2LYoyfWGC4LdYoYKKsKpjTnQFQaNZKDWRS (fe653f96...)
    // Identity: kapC1fvHPhkg5i2ARyEpoDyGzyFZzQK4S7XnBhBki93 (0b2a353d...)

    // Real document proof from logs (1273 bytes)
    let document_proof = hex::decode("008d01a11bbabcdc129030db24072efba3172219391cd52edb61cf6f62c517187ef7fc04014000240201205bb4077299c35f3d25823bac24779abe40e3e0ff4d76104b5b6a074687142a4800d598deaab3433069e18a87ee115c32272e900da15e8993adfa0b8124260faa871001dbdd6988bb91ccb3c00397d402e3b10fdaae01e382f2951806ef3b0d77512d5311010140fb028b0141f9790f8ee0b9faf3a1ef24a85d4f9376cd003807a45c979fbfe741eba40785028e1c0b2fe4c55e4891e72047aa134b49121e86b7816bdebc8ddb10b0c5d7126010019cc5eef8f284be5cbcb4c60e102ed80f8c65c1a698a9f2b2ecf9ad288887afa602472cdee36f03a9548b6173d20a323d6f5f82a722d1ad05b34f189c5c6b25294a1001487e98039043f388830ad9b5ceba0ea2caea90b5f22678b332f54fe3f4af804f02c7a957db2518ce3845b356d4c8d87c48054d17aa63a1987468bbf384be708da210012839d58ef9dbe5703ddd9cfce05a5aee2bdf385a07a603037ac3a0d58540080402fcf9335072821922004e4315b5be2f3e2695e6f740dae8d0bc74a038cad05d1b1001c3c8105c9628031a3758be7afc04d51a9633c9e4df061000332e1244f95ae3fe029bd9cb9ddceaa2b83e6243731ac1d5a35a5ca52f7a606b45561bc0160b55e89c10023a3aa08eafdcb1f910ccf1e6e46330b46d007cb38899b534ab8c08c5c6426c5b042057e5c248f52c7d15857a3af8525749caced7b8399c0ed3221c3648026370230600050201010100260c03151892264960e70272b6667ce8717902c5e69af0c9953a5653bf53826411023cf0248f9997b40fe5b248d9ff068d151c14e328dcf3c21cbeb14fcf0e753c4f10018016c1dd0bf2b28fdc06b415e03b6ac2a489e6eccb28eb5bc38f13f0a2c7beda1111026153686780ee38204610d502f16bce91b9620ca3fb9be9a773115f05be005f7910015399c590d2cb9599905a82ddeb23344aed92f910d8bea4832608dee794c22005111111111102f5a40b154096932fa4f0f0a0058553d8e34dadbb5536d789ab8d8da8be8fffc31001ea5b569472f90e0dcb2a66f06be520a7283a2404e30f245e17c2a90862e9bbbb11012057e5c248f52c7d15857a3af8525749caced7b8399c0ed3221c364802637023064f012dc2833acd51e23e40ad7ab1e2abbd0745a54c13b265a1cd46bf0f88d03d87860401010008020104626c6f6200d84dd6907e1c4977368d8b652259e86c2926689f42a045fe7a22027d76d2a302100101013c0404626c6f62001402011073616c746564446f6d61696e4861736800a9cf0b4fd9197d1e18977c30cbf3f032ddfd1d9c5bd9b0f78484dbfd29a130340104626c6f626b040100002402012057840ab06c0d15a5542aedf4e3df9bd854835ce24a4139e65f4b63764864890c002c04e9dff2e94ee7064bd870bbf0eac280822ac8cbb7bf920568ff785289f97002884ca74cafb81cdfbb72b67d205279dfe83e59d244695b99f9e27dfa8cf43e9210010100af032057840ab06c0d15a5542aedf4e3df9bd854835ce24a4139e65f4b63764864890c008b00640157840ab06c0d15a5542aedf4e3df9bd854835ce24a4139e65f4b63764864890cfe653f96bfa2c977e39772e1167717dccb4e86371c7e97eb570c9e5dd43cc05d010000747616d18ba23f832de0139829ac5b4ba8ab1273f1b5c9ae9a1b2aa30434f79f012302fe653f96bfa2c977e39772e1167717dccb4e86371c7e97eb570c9e5dd43cc05d25830001").unwrap();

    // Real key proof from logs (1332 bytes)
    let key_proof = hex::decode("00d10129affee1360cafbf42c950cd44aeb180fde0c3c7a27144889c0453357665ec4204012000240201207dec59e08c02ff8b954769c3cb9d5a74f6eb0e2c8cd5a056fba4c47f1e5f545a0081ff65e49e31734dd241d391d4d639c7e41912d2d16316d2bb4463028888dafa1001fbf3e68c4fb9b6fb06bc54d5885af10ce049ce80ae3f67c8142a5922be4f6f3b11021da2eee83088bd363c34ae73946a5527d45b0b4a8d402622b64406fcc6b721f61001dbdd6988bb91ccb3c00397d402e3b10fdaae01e382f2951806ef3b0d77512d5311010120fb0339011c50efea191ee92349486d8367392c1ed0f4f0333490236a9ccc13851aaed40002e917174936b97fc29647f1748155a2a732a99202444c7e4b3e90bec9142760b610014df237d5310ce542a0d4e657558ddf28776cdcb2f97e12f410d90913db5a3c6e027be4ddcd9b6b33e19b80e45d713f21c2f4d068083604112c8951a2a06e778eca1001e7a9e14059ad74250c2c58fbce8d389b011121a6a7064ba4884ca28916822c8b02256c8d117b275a8ba6c2f57327f73b76aa10f73f40a8bce048d32302092739e410013b90b679af1038bd2993d796638a25395505cfaa435c869f876578c0d17f837502a3aabeca7f479277bbb0b47e03e71ac57f8890252fa37285374d810cb6351b7f100184c0d8b3e4e7aa8914341ce39aad2d56cf401f10296e19081c21c33a0e00891104200b2a353d88e71baeb64bdb1806559d3bca884fb7a2ddcec2ef6c28cc63d9b1ee0009020101800103002583ebc2512d5fa0ed8d9e17f6dda722ecdd6f57e47420e9676539dc90e4532c141810010562ddf1a9e1b3b37ef55d03825512c4061bb0eef7f04739ee68010b181cbc0811111102104c8d749532fb4c43c0f82c9f32bafd554676936238a060401accd80955e26e1001f2a7c400553780d1f0478e7eb792a6d0b05a7917e96282c6b3d7933a3e2397671102bfc3394c2113753c3070ab98c98e4e0634ef8254bd7e569dac0e1fa891044d58100188962f6d18249b2764d76395ea0572e180bfa31a3183195bf0bd9648bbd411a011111102e0d42720df15a97a1b563b97c5e46e8279e992290c8946298aaa31d01298d71010015f3a7ece97c871e53ac978476fb4048f8f249d4fff5aba63d3ec5c8256c11df411027a63910e44012c923d2c25dc6e980c263ff0c5bccd457142affd455ee34f18081001ffbe944cec934f6cc7b5e6e881e6ad411342d3711a31bc4011e20f66649fbd0711021df673711ee28ed6fed05a473a439033620be4ed376eee495309f640dc9a8fee1001e5a61fd295627670c87f1a477feb3bac3548dad1a403b083f28bbfdb0c3de31611020e703c94077502209bfed96e14b7a98f554929c572d8db2d805d9b4d0c1159d61001a676d255a4a9ba99bbcad794c3bf716bb8ce3b7cba470b84fbc67046bd1ba8701101200b2a353d88e71baeb64bdb1806559d3bca884fb7a2ddcec2ef6c28cc63d9b1ee6e017224fbf0aeb0f0a1ea9d45f7ae12d793215b8e93dd47663d75c35f2287e0890804018000050201010200fe0801ff72f2060bdec9589fea9fe3caf06aa23236eca5f63910ef9e90a587c11001a4c56f144798b9a49ff16be004e69a2c77a2488ba77809e0df2c3395d535aed2110101808b01f9b744d02a748af605ab7423e6f3eb571927b9a7f61f0f52da3d061058949a7e02e9762ac43e59d4706050a7721c0fbcbdf72f4203ba48127881d96afdc248d99a10023208344960c10076733ee32604bade1660f4815d065daaa2aae540579aea70bd0301040020001d0004000100040014db510ef1ea5b649d85a026ff853a11ab1f10d3bb000011110001").unwrap();

    // Real document JSON from logs
    let document_json = r#"{"$version":"0","$id":"6tdFPcjK3Sn1dJAufkQCaH4HeuB8kX1pqjiu95idfzn7","$ownerId":"J846nouwbX2LYoyfWGC4LdYoYKKsKpjTnQFQaNZKDWRS","saltedDomainHash":"dHYW0YuiP4Mt4BOYKaxbS6irEnPxtcmumhsqowQ0958=","$revision":1,"$createdAt":null,"$updatedAt":null,"$transferredAt":null,"$createdAtBlockHeight":null,"$updatedAtBlockHeight":null,"$transferredAtBlockHeight":null,"$createdAtCoreBlockHeight":null,"$updatedAtCoreBlockHeight":null,"$transferredAtCoreBlockHeight":null}"#;

    // Real EdDSA signature components from logs
    let signature_r: [u8; 32] =
        hex::decode("f1ff3d8f47ad6a6bf08bda43e7f69724b59c19a22eca389e1a1879bd99db55c6")
            .unwrap()
            .try_into()
            .unwrap();
    let signature_s: [u8; 32] =
        hex::decode("3c59b013e64ffb946adf5625c4df7521096ef246d12857e4000be7014cb3850a")
            .unwrap()
            .try_into()
            .unwrap();
    let public_key: [u8; 32] =
        hex::decode("3f434942895d1a0ef9a29118e69cb379b4e0da0fa904bb1b24fdc6deeba21eaa")
            .unwrap()
            .try_into()
            .unwrap();
    let private_key: [u8; 32] =
        hex::decode("5f0dd00fd48b2afb39088eecfd88c27154c747f16a01abbd09f6c55a965dd59f")
            .unwrap()
            .try_into()
            .unwrap();
    let message: [u8; 32] =
        hex::decode("834da9f1c17e59130f247cb621cda4dcf234a022e5d72efb6c20965eee8797f6")
            .unwrap()
            .try_into()
            .unwrap();

    // Real state root from logs
    let state_root: [u8; 32] =
        hex::decode("008d01a11bbabcdc129030db24072efba3172219391cd52edb61cf6f62c51718")
            .unwrap()
            .try_into()
            .unwrap();

    // Real contract ID
    let contract_id: [u8; 32] =
        hex::decode("57e5c248f52c7d15857a3af8525749caced7b8399c0ed3221c36480263702306")
            .unwrap()
            .try_into()
            .unwrap();

    println!("Document owner: J846nouwbX2LYoyfWGC4LdYoYKKsKpjTnQFQaNZKDWRS");
    println!("Identity:       kapC1fvHPhkg5i2ARyEpoDyGzyFZzQK4S7XnBhBki93");
    println!("These are DIFFERENT - proof MUST fail!");

    // Create witness using the no_validation version (simulating the vulnerability)
    let witness = create_witness_from_platform_proofs(
        &document_proof,
        &key_proof,
        document_json.as_bytes().to_vec(),
        &public_key,
        &signature_r,
        &signature_s,
        &message,
        &private_key,
    )
    .expect("Failed to create witness");

    println!("\nWitness created with:");
    println!("  owner_id:    {}", hex::encode(&witness.owner_id));
    println!("  identity_id: {}", hex::encode(&witness.identity_id));

    // Use production config
    let config = STARKConfig::default();
    let prover = GroveSTARK::with_config(config);

    let public_inputs = PublicInputs {
        state_root,
        contract_id,
        message_hash: message,
        timestamp: 1700000000,
    };

    // Try to generate proof
    match prover.prove(witness, public_inputs.clone()) {
        Ok(proof) => {
            println!("âš ï¸ WARNING: Proof was generated with mismatched IDs!");
            println!("Now verifying the proof...");

            // This MUST fail verification
            let verify_result = prover.verify(&proof, &public_inputs);
            println!("ðŸ” prover.verify() returned: {:?}", verify_result);

            match verify_result {
                Ok(true) => {
                    panic!(
                        "ðŸš¨ðŸš¨ðŸš¨ CRITICAL SECURITY VULNERABILITY ðŸš¨ðŸš¨ðŸš¨\n\
                           Proof with mismatched owner/identity PASSED verification!\n\
                           This allows anyone to prove ownership of documents they don't own!"
                    );
                }
                Ok(false) => {
                    println!("âœ… Good: Verification correctly rejected the mismatched IDs");
                }
                Err(e) => {
                    println!("âœ… Good: Verification failed with error: {}", e);
                }
            }
        }
        Err(e) => {
            // Check the error
            if e.to_string().contains("EdDSA") {
                println!("Proof generation failed at EdDSA (not the vulnerability we're testing)");
            } else {
                println!("Proof generation failed: {}", e);
            }
        }
    }
}

#[test]
fn test_diff_accumulator_enforcement() {
    println!("\n=== DIFF ACCUMULATOR TEST ===");
    println!("Testing if DIFF_ACC boundary assertions are enforced");

    // The DIFF_ACC should accumulate squared differences
    // If owner != identity, DIFF_ACC becomes non-zero and should fail at boundary

    let mut witness = TestUtils::create_test_witness();

    // Create a small mismatch
    witness.owner_id[0] = 1;
    witness.identity_id[0] = 2; // Just 1 byte different

    println!("Created 1-byte mismatch in IDs");

    let config = STARKConfig::default();
    let prover = GroveSTARK::with_config(config);

    // Use non-zero values for public inputs
    let public_inputs = PublicInputs {
        state_root: [1u8; 32],
        contract_id: [2u8; 32],
        message_hash: [3u8; 32],
        timestamp: 1700000000,
    };

    match prover.prove(witness, public_inputs.clone()) {
        Ok(proof) => {
            println!("âš ï¸ Proof generated despite mismatch");

            match prover.verify(&proof, &public_inputs) {
                Ok(true) => {
                    panic!("ðŸš¨ VULNERABILITY: DIFF_ACC not enforced!");
                }
                Ok(false) => {
                    println!("âœ… DIFF_ACC correctly rejected mismatch");
                }
                Err(e) => {
                    println!("âœ… Verification error: {}", e);
                }
            }
        }
        Err(e) => {
            println!("Proof generation failed: {}", e);
        }
    }
}
