#![allow(dead_code)]

#[cfg(test)]
mod prop {
    use curve25519_dalek::{
        constants::ED25519_BASEPOINT_TABLE, edwards::EdwardsPoint, scalar::Scalar,
    };
    use rand_chacha::ChaCha20Rng;
    use rand_core::{RngCore, SeedableRng};

    // ---- bring your symbols into scope ----
    use grovestark::crypto::fe25519_digits as fe;
    use grovestark::crypto::point_decompression::decompress_ed25519_point;
    use grovestark::crypto::scalar_mult_correct::{ed_add, ed_double, ExtPoint};

    // --------- helpers: field/point utilities ----------

    #[inline]
    fn fe_eq(a: &[u16; 16], b: &[u16; 16]) -> bool {
        let mut aa = *a;
        let mut bb = *b;
        fe::canonicalize(&mut aa);
        fe::canonicalize(&mut bb);
        aa == bb
    }

    #[inline]
    fn fe_zero() -> [u16; 16] {
        [0u16; 16]
    }
    #[inline]
    fn fe_one() -> [u16; 16] {
        let mut x = [0u16; 16];
        x[0] = 1;
        x
    }

    // d = -121665/121666 mod p, computed programmatically (no hardcoded limbs)
    #[inline]
    fn edwards_d() -> [u16; 16] {
        fn from_u32(v: u32) -> [u16; 16] {
            let mut o = [0u16; 16];
            o[0] = (v & 0xffff) as u16;
            o[1] = (v >> 16) as u16;
            o
        }
        let num = from_u32(121665);
        let den = from_u32(121666);
        let den_inv = fe::invert(&den);
        let d = fe::mul(&fe::neg(&num), &den_inv);
        let mut can = d;
        fe::canonicalize(&mut can);
        can
    }

    #[inline]
    fn assert_invariants(tag: &str, p: &ExtPoint) {
        // (I1) T·Z == X·Y
        let tz = fe::mul(&p.t, &p.z);
        let xy = fe::mul(&p.x, &p.y);
        assert!(fe_eq(&tz, &xy), "{tag}: invariant (I1) failed: T·Z != X·Y");

        // (I2) Y² − X² == Z² + d·T²
        let y2 = fe::sqr(&p.y);
        let x2 = fe::sqr(&p.x);
        let z2 = fe::sqr(&p.z);
        let t2 = fe::sqr(&p.t);
        let lhs = fe::sub(&y2, &x2);
        let rhs = fe::add(&z2, &fe::mul(&edwards_d(), &t2));
        assert!(
            fe_eq(&lhs, &rhs),
            "{tag}: invariant (I2) failed: Y²−X² != Z² + d·T²"
        );
    }

    // Projective identity check: (0 : 1 : 1 : 0)
    #[inline]
    fn is_identity_projective(p: &ExtPoint) -> bool {
        let zero = fe_zero();
        let one = fe_one();
        fe_eq(&p.x, &zero) && fe_eq(&p.t, &zero) && fe_eq(&p.y, &p.z) && fe_eq(&p.y, &one)
    }

    // Negation (critical: negate X and T, leave Y,Z)
    #[inline]
    fn ed_neg(p: &ExtPoint) -> ExtPoint {
        ExtPoint {
            x: fe::neg(&p.x),
            y: p.y,
            z: p.z,
            t: fe::neg(&p.t),
        }
    }

    // Compute affine y = Y / Z and return 32 little-endian bytes
    #[inline]
    fn affine_y_le_bytes(p: &ExtPoint) -> [u8; 32] {
        let z_inv = fe::invert(&p.z);
        let y_aff = fe::mul(&p.y, &z_inv);
        limbs16_to_le32(&y_aff)
    }

    #[inline]
    fn limbs16_to_le32(limbs: &[u16; 16]) -> [u8; 32] {
        let mut x = *limbs;
        fe::canonicalize(&mut x);
        let mut out = [0u8; 32];
        for i in 0..16 {
            out[2 * i] = (x[i] & 0x00ff) as u8;
            out[2 * i + 1] = (x[i] >> 8) as u8;
        }
        out
    }

    // Decompress a dalek point via its compressed Y (using your implementation)
    #[inline]
    fn ext_from_dalek(p: &EdwardsPoint) -> ExtPoint {
        let bytes = p.compress().to_bytes(); // y || sign
                                             // Your decompress returns extended with Z=1 and T=X·Y
        let ep = decompress_ed25519_point(&bytes)
            .expect("decompress should succeed for a valid dalek point");
        // Convert to ExtPoint format
        ExtPoint {
            x: ep.x,
            y: ep.y,
            z: ep.z,
            t: ep.t,
        }
    }

    // Mask sign bit out of dalek's compressed Y for comparing affine Y
    #[inline]
    fn dalek_y_bytes_no_sign(p: &EdwardsPoint) -> [u8; 32] {
        let mut y = p.compress().to_bytes();
        y[31] &= 0x7F;
        y
    }

    // -------------------- PROPERTIES --------------------

    // 1) Invariants hold for random points (generated by dalek), and P+(-P) = identity.
    #[test]
    fn prop_invariants_and_cancel() {
        let mut rng = ChaCha20Rng::from_seed([7u8; 32]);

        for i in 0..200 {
            // random scalar -> dalek point
            let mut s_bytes = [0u8; 32];
            rng.fill_bytes(&mut s_bytes);
            let s = Scalar::from_bytes_mod_order(s_bytes);
            let p_d = &s * ED25519_BASEPOINT_TABLE;

            // convert through your decompressor
            let p = ext_from_dalek(&p_d);

            // invariants on P
            assert_invariants("P", &p);

            // negation preserves invariants
            let neg_p = ed_neg(&p);
            assert_invariants("neg(P)", &neg_p);

            // P + (-P) => identity
            let r = ed_add(&p, &neg_p);
            // X=0, T=0, Y==Z (not necessarily equal to 1 yet)
            assert!(fe_eq(&r.x, &fe_zero()), "case {i}: X != 0 in P+(-P)");
            assert!(fe_eq(&r.t, &fe_zero()), "case {i}: T != 0 in P+(-P)");
            assert!(fe_eq(&r.y, &r.z), "case {i}: Y != Z in P+(-P)");
            assert_invariants("P+(-P)", &r);
        }
    }

    // 2) Affine Y matches dalek after add and double (strong cross-check).
    #[test]
    fn prop_affine_y_matches_dalek_for_add_and_double() {
        let mut rng = ChaCha20Rng::from_seed([9u8; 32]);

        for i in 0..120 {
            // P = s*B, Q = t*B
            let mut sb = [0u8; 32];
            rng.fill_bytes(&mut sb);
            let mut tb = [0u8; 32];
            rng.fill_bytes(&mut tb);
            let s = Scalar::from_bytes_mod_order(sb);
            let t = Scalar::from_bytes_mod_order(tb);

            let p_d = &s * ED25519_BASEPOINT_TABLE;
            let q_d = &t * ED25519_BASEPOINT_TABLE;

            // P, Q via your path
            let p = ext_from_dalek(&p_d);
            let q = ext_from_dalek(&q_d);

            // ---- ADD ----
            let sum = ed_add(&p, &q);
            let sum_d = p_d + q_d;

            // compare affine Y bytes (ignore sign bit)
            let y_sum = affine_y_le_bytes(&sum);
            let mut y_sum_d = dalek_y_bytes_no_sign(&sum_d);
            // mask sign for comparison
            y_sum_d[31] &= 0x7F;
            assert_eq!(y_sum, y_sum_d, "case {i}: affine Y mismatch on P+Q");
            assert_invariants("P+Q", &sum);

            // ---- DOUBLE ----
            let dbl = ed_double(&p);
            let dbl_d = p_d + p_d;

            let y_dbl = affine_y_le_bytes(&dbl);
            let mut y_dbl_d = dalek_y_bytes_no_sign(&dbl_d);
            y_dbl_d[31] &= 0x7F;
            assert_eq!(y_dbl, y_dbl_d, "case {i}: affine Y mismatch on 2P");
            assert_invariants("2P", &dbl);
        }
    }
}
