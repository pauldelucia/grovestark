//! Tests demonstrating that the critical security vulnerability is fixed
//!
//! The vulnerability: Previously, anyone could claim ownership of any document
//! The fix: Identity binding ensures only the true owner can generate valid proofs

use grovestark::create_witness_from_platform_proofs;
use hex;

// Fixture loader for PASS (valid) and FAIL (mismatched) cases
fn load_fixtures() -> (
    Vec<u8>,  // document_proof
    Vec<u8>,  // key_proof_pass
    Vec<u8>,  // key_proof_fail (mismatch)
    Vec<u8>,  // document_json bytes
    [u8; 32], // pubkey
    [u8; 32], // sig_r
    [u8; 32], // sig_s
    Vec<u8>,  // message bytes
) {
    #[derive(serde::Deserialize)]
    struct Ed25519Fix {
        public_key_hex: String,
        signature_r_hex: String,
        signature_s_hex: String,
    }
    #[derive(serde::Deserialize)]
    struct PubInputsFix {
        message_hex: String,
    }
    #[derive(serde::Deserialize)]
    struct PassFix {
        document_json: String,
        document_proof_hex: String,
        key_proof_hex: String,
        public_inputs: PubInputsFix,
        ed25519: Ed25519Fix,
    }
    #[derive(serde::Deserialize)]
    struct FailFix {
        key_proof_hex_fail: String,
    }
    #[derive(serde::Deserialize)]
    struct Fixtures {
        pass: PassFix,
        fail: FailFix,
    }

    fn hex32(s: &str) -> [u8; 32] {
        let v = hex::decode(s).unwrap();
        let mut out = [0u8; 32];
        out.copy_from_slice(&v);
        out
    }

    let fixtures: Fixtures =
        serde_json::from_str(include_str!("fixtures/PASS_AND_FAIL.json")).unwrap();
    let document_proof = hex::decode(&fixtures.pass.document_proof_hex).unwrap();
    let key_proof_pass = hex::decode(&fixtures.pass.key_proof_hex).unwrap();
    let key_proof_fail = hex::decode(&fixtures.fail.key_proof_hex_fail).unwrap();
    let pubkey = hex32(&fixtures.pass.ed25519.public_key_hex);
    let sig_r = hex32(&fixtures.pass.ed25519.signature_r_hex);
    let sig_s = hex32(&fixtures.pass.ed25519.signature_s_hex);
    let message = hex::decode(&fixtures.pass.public_inputs.message_hex).unwrap();
    (
        document_proof,
        key_proof_pass,
        key_proof_fail,
        fixtures.pass.document_json.as_bytes().to_vec(),
        pubkey,
        sig_r,
        sig_s,
        message,
    )
}

#[test]
fn test_legitimate_owner_succeeds() {
    println!("\nüîì Testing Legitimate Owner Access");
    println!("===================================");

    // Load valid pass fixtures for legitimate owner
    let (
        document_proof,
        key_proof_pass,
        _key_proof_fail,
        document_json,
        pubkey,
        sig_r,
        sig_s,
        message,
    ) = load_fixtures();

    let result = create_witness_from_platform_proofs(
        &document_proof,
        &key_proof_pass,
        document_json,
        &pubkey,
        &sig_r,
        &sig_s,
        &message,
    );

    // Alice should SUCCEED!
    assert!(
        result.is_ok(),
        "‚ùå ERROR: Alice cannot access her own document!"
    );

    if let Ok(witness) = result {
        assert_eq!(witness.owner_id, witness.identity_id);
        println!("‚úÖ Alice successfully proved ownership of her document");
        println!("   Owner ID matches Identity ID");
    }
}
