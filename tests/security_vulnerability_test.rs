//! Tests demonstrating that the critical security vulnerability is fixed
//!
//! The vulnerability: Previously, anyone could claim ownership of any document
//! The fix: Identity binding ensures only the true owner can generate valid proofs

use grovestark::create_witness_from_platform_proofs;
use hex;

// Fixture loader for PASS (valid) and FAIL (mismatched) cases
fn load_fixtures() -> (
    Vec<u8>,  // document_proof
    Vec<u8>,  // key_proof_pass
    Vec<u8>,  // key_proof_fail (mismatch)
    Vec<u8>,  // document_json bytes
    [u8; 32], // pubkey
    [u8; 32], // sig_r
    [u8; 32], // sig_s
    Vec<u8>,  // message bytes
    [u8; 32], // private_key
) {
    #[derive(serde::Deserialize)]
    struct Ed25519Fix {
        public_key_hex: String,
        signature_r_hex: String,
        signature_s_hex: String,
        private_key_hex: String,
    }
    #[derive(serde::Deserialize)]
    struct PubInputsFix {
        state_root_hex: String,
        contract_id_hex: String,
        message_hex: String,
        timestamp: u64,
    }
    #[derive(serde::Deserialize)]
    struct PassFix {
        document_json: String,
        document_proof_hex: String,
        key_proof_hex: String,
        public_inputs: PubInputsFix,
        ed25519: Ed25519Fix,
    }
    #[derive(serde::Deserialize)]
    struct FailFix {
        key_proof_hex_fail: String,
    }
    #[derive(serde::Deserialize)]
    struct Fixtures {
        pass: PassFix,
        fail: FailFix,
    }

    fn hex32(s: &str) -> [u8; 32] {
        let v = hex::decode(s).unwrap();
        let mut out = [0u8; 32];
        out.copy_from_slice(&v);
        out
    }

    let fixtures: Fixtures =
        serde_json::from_str(include_str!("fixtures/PASS_AND_FAIL.json")).unwrap();
    let document_proof = hex::decode(&fixtures.pass.document_proof_hex).unwrap();
    let key_proof_pass = hex::decode(&fixtures.pass.key_proof_hex).unwrap();
    let key_proof_fail = hex::decode(&fixtures.fail.key_proof_hex_fail).unwrap();
    let pubkey = hex32(&fixtures.pass.ed25519.public_key_hex);
    let sig_r = hex32(&fixtures.pass.ed25519.signature_r_hex);
    let sig_s = hex32(&fixtures.pass.ed25519.signature_s_hex);
    let private_key = hex32(&fixtures.pass.ed25519.private_key_hex);
    let message = hex::decode(&fixtures.pass.public_inputs.message_hex).unwrap();
    (
        document_proof,
        key_proof_pass,
        key_proof_fail,
        fixtures.pass.document_json.as_bytes().to_vec(),
        pubkey,
        sig_r,
        sig_s,
        message,
        private_key,
    )
}

#[test]
fn test_vulnerability_is_fixed() {
    println!("\nüîí Testing Security Vulnerability Fix");
    println!("=====================================");

    // Use fixtures: pass document proof with mismatched key proof to simulate attacker
    let (
        document_proof,
        _key_proof_pass,
        key_proof_fail,
        document_json,
        pubkey,
        sig_r,
        sig_s,
        message,
        privkey,
    ) = load_fixtures();

    let result = create_witness_from_platform_proofs(
        &document_proof,
        &key_proof_fail, // mismatched identity
        document_json,
        &pubkey,
        &sig_r,
        &sig_s,
        &message,
        &privkey,
    );

    // The attack should FAIL!
    assert!(
        result.is_err(),
        "‚ùå VULNERABILITY: Bob was able to claim Alice's document!"
    );

    if let Err(e) = result {
        let error_msg = format!("{}", e);
        println!("Error received: {}", error_msg);
        assert!(
            error_msg.contains("Identity doesn't own document"),
            "Error should indicate ownership mismatch, got: {}",
            error_msg
        );
        println!("‚úÖ Attack prevented: {}", error_msg);
    }

    println!("\n‚úÖ Security vulnerability is FIXED!");
    println!("   Bob cannot claim ownership of Alice's document");
}

#[test]
fn test_legitimate_owner_succeeds() {
    println!("\nüîì Testing Legitimate Owner Access");
    println!("===================================");

    // Load valid pass fixtures for legitimate owner
    let (
        document_proof,
        key_proof_pass,
        _key_proof_fail,
        document_json,
        pubkey,
        sig_r,
        sig_s,
        message,
        privkey,
    ) = load_fixtures();

    let result = create_witness_from_platform_proofs(
        &document_proof,
        &key_proof_pass,
        document_json,
        &pubkey,
        &sig_r,
        &sig_s,
        &message,
        &privkey,
    );

    // Alice should SUCCEED!
    assert!(
        result.is_ok(),
        "‚ùå ERROR: Alice cannot access her own document!"
    );

    if let Ok(witness) = result {
        assert_eq!(witness.owner_id, witness.identity_id);
        println!("‚úÖ Alice successfully proved ownership of her document");
        println!("   Owner ID matches Identity ID");
    }
}

#[test]
fn test_cross_identity_attack_prevented() {
    println!("\nüö´ Testing Cross-Identity Attack Prevention");
    println!("==========================================");

    // Charlie tries a sophisticated attack:
    // 1. He has a legitimate key in Platform
    // 2. He tries to use it to claim Dave's document

    // Cross-identity attack: pass document with mismatched key proof (fixtures)
    let (
        document_proof,
        _key_proof_pass,
        key_proof_fail,
        document_json,
        pubkey,
        sig_r,
        sig_s,
        message,
        privkey,
    ) = load_fixtures();

    let result = create_witness_from_platform_proofs(
        &document_proof,
        &key_proof_fail,
        document_json,
        &pubkey,
        &sig_r,
        &sig_s,
        &message,
        &privkey,
    );

    // Attack should FAIL!
    assert!(
        result.is_err(),
        "‚ùå VULNERABILITY: Charlie claimed Dave's document!"
    );

    println!("‚úÖ Cross-identity attack prevented");
    println!("   Charlie cannot use his legitimate key to claim Dave's document");
}
