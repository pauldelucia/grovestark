use grovestark::parser::proof_decoder::parse_det_proof_format;
use hex;

#[test]
fn test_actual_parsing_no_fallback() {
    // Document proof from DET_PROOF_LOGS.md
    let doc_proof_hex = "008d01df2b7bb6e932d43346b57bee9e4294556918af5e88191d2da318ce6ab7ff2dc904014000240201205bb4077299c35f3d25823bac24779abe40e3e0ff4d76104b5b6a074687142a4800e1087bd1e12d3e63369913b0a6a96d6ad9b7934dd71f51b8abf1a840282d009d10013d0791d300d9b21bbf5c93758a411d27f7b61fb3307d4ba6d43ad78fdf8d646911010140fb028b01985931c823f722968e943c663da32f74a00e06a9ae866c44ae85544cef7dc799028e1c0b2fe4c55e4891e72047aa134b49121e86b7816bdebc8ddb10b0c5d7126010019cc5eef8f284be5cbcb4c60e102ed80f8c65c1a698a9f2b2ecf9ad288887afa602472cdee36f03a9548b6173d20a323d6f5f82a722d1ad05b34f189c5c6b25294a1001487e98039043f388830ad9b5ceba0ea2caea90b5f22678b332f54fe3f4af804f02c7a957db2518ce3845b356d4c8d87c48054d17aa63a1987468bbf384be708da210012839d58ef9dbe5703ddd9cfce05a5aee2bdf385a07a603037ac3a0d58540080402fcf9335072821922004e4315b5be2f3e2695e6f740dae8d0bc74a038cad05d1b1001c3c8105c9628031a3758be7afc04d51a9633c9e4df061000332e1244f95ae3fe029bd9cb9ddceaa2b83e6243731ac1d5a35a5ca52f7a606b45561bc0160b55e89c10023a3aa08eafdcb1f910ccf1e6e46330b46d007cb38899b534ab8c08c5c6426c5b042057e5c248f52c7d15857a3af8525749caced7b8399c0ed3221c3648026370230600050201010100260c03151892264960e70272b6667ce8717902c5e69af0c9953a5653bf53826411023cf0248f9997b40fe5b248d9ff068d151c14e328dcf3c21cbeb14fcf0e753c4f10018016c1dd0bf2b28fdc06b415e03b6ac2a489e6eccb28eb5bc38f13f0a2c7beda1111026153686780ee38204610d502f16bce91b9620ca3fb9be9a773115f05be005f7910015399c590d2cb9599905a82ddeb23344aed92f910d8bea4832608dee794c22005111111111102f5a40b154096932fa4f0f0a0058553d8e34dadbb5536d789ab8d8da8be8fffc3100113fa02c86f511b00bf7faaee9fbd14a54b6a33b25fb7d7f7861bd3df4ac9321511012057e5c248f52c7d15857a3af8525749caced7b8399c0ed3221c364802637023064f012dc2833acd51e23e40ad7ab1e2abbd0745a54c13b265a1cd46bf0f88d03d87860401010008020104626c6f6200d84dd6907e1c4977368d8b652259e86c2926689f42a045fe7a22027d76d2a302100101013c0404626c6f62001402011073616c746564446f6d61696e4861736800a9cf0b4fd9197d1e18977c30cbf3f032ddfd1d9c5bd9b0f78484dbfd29a130340104626c6f626b040100002402012057840ab06c0d15a5542aedf4e3df9bd854835ce24a4139e65f4b63764864890c002c04e9dff2e94ee7064bd870bbf0eac280822ac8cbb7bf920568ff785289f97002884ca74cafb81cdfbb72b67d205279dfe83e59d244695b99f9e27dfa8cf43e9210010100af032057840ab06c0d15a5542aedf4e3df9bd854835ce24a4139e65f4b63764864890c008b00640157840ab06c0d15a5542aedf4e3df9bd854835ce24a4139e65f4b63764864890cfe653f96bfa2c977e39772e1167717dccb4e86371c7e97eb570c9e5dd43cc05d010000747616d18ba23f832de0139829ac5b4ba8ab1273f1b5c9ae9a1b2aa30434f79f012302fe653f96bfa2c977e39772e1167717dccb4e86371c7e97eb570c9e5dd43cc05d25830001";

    let key_proof_hex = "00d10181f2b85a427468292f1867fe05a078228df9699ebaade36518739f7646d77a9604012000240201207dec59e08c02ff8b954769c3cb9d5a74f6eb0e2c8cd5a056fba4c47f1e5f545a0097ea80cf0b43a8f5204f9bbcf9e3735ebf394f240bc61b5b35e92ff6326258e11001069ea9c1b2a57243be47047f2625a6eca8b3d6f3b87fd9ef054a11b29c7742391102f557c5545b3d02aef6e3dd41b4b8bc08323a738ebfd75555ce1be9adb5413d9510013d0791d300d9b21bbf5c93758a411d27f7b61fb3307d4ba6d43ad78fdf8d646911010120fb031701340a0c95e5a507b7b739a8c2cdd5e299b99117dcd0c97071f78b75e57351db7d020e703c94077502209bfed96e14b7a98f554929c572d8db2d805d9b4d0c1159d6100199e510d83695aef67ac5edd44eabc5ae3259788fed51c0939806ed451f7cfedf021c126c2cf2765ff9b2e464d8207a6645520ef7767ed3e5ad4f6a242fe38783f41001b4456a5cd97ed23c289eb02fcd00d1cb0aac131bbd9f8431f664a546693cde4e023d9a5e0a2ec2017f1857ddc3c3e6b409ac9d0aabd0f0581812fd2a9a4bd86d3410013428debc4d784808b5a36b6fd7209416368e2dc6a893e54f2f151d106f4e3a77027e797a0d8d74d1818b358d05d949f228758ccb48c44cb7abe1b7168a604408a4100182810c198d6b88f830bba3b9bd70f27a0d51509991ae4a8949366adc3cd26295029e61f1bd8d1302a50c8af5553be6ee268e53702d09c5bb0d099218265385f53710013f7e0e41f733ceb1847d9682b0c9a87e81c3b2f5707a68681f0834314d9b0d74027e4cf1c2441b14882388a56f758923893cd9d05e8ba28cfae00b20b91f2cd7121001292e614808da00c274375176ac3496a134a807d4954c3207ae373302fe25e16b0224fd6e91fc6dc66ac5d4ac4ebad40f24ac98f0403bbd40a850fb9259bd53c7b2100121aafde049fd5ee614f3f39f9295e938c2ac21c10ed149001024a4d1f1d9c08602b79385586f6069c40aaf65e529cc468659fc169d7e5adbbc69c5c31e7706f9f41002804f354e78e573b863656a9281d6befea040550b4302b347ab653e599bc3881f0420fe653f96bfa2c977e39772e1167717dccb4e86371c7e97eb570c9e5dd43cc05d00090201018001030025839be711f0242f48a499c7a32a3d3fa99b36ce19e6f51f76f6a30ab1cf41ff28b411026a94bdf24a25ff627bdd9cc87d2f4678334f93350f561f1d41b41501a521a72c1001c6bb735a35b155ddf3332002f4f59f544e33cc3e8c7ed921eb0e3f361acd971a111102bc096d7e1f801b01535edd9859258fbcfe5ef98afe767dccc0db4b23515acd9a100163874dddad6d01c66f7443c011eebac008a363233f948532c9c0ff3bf98f588811111111111111110120fe653f96bfa2c977e39772e1167717dccb4e86371c7e97eb570c9e5dd43cc05d6e012d13c471e57a327a4edfb6ed0af9f3356891bb5b8cf9f7145d44effcf5cf15f004018000050201010200b50bc4c371dcfe857b389bf8eacfb3103f7c1cae3d504e7f073e85f491d1620c1001b3883a197501d381699002c0990f5a2ae08b085e2692ef277febe333e8f06a8e110101808b01f426e6c5b244f86db0fc44832cd08ff959f955b1b8db15df770d4605556c935902823c052b953a4e8a6b731c441310c6e309249fd1024a3cb6e35204a7ff211f6b10027f4c54418f079e7b52c9d80e66dbcffe664d3b964856ac1aff61f253f7669f1b0301040020001d00040001000400146bccd4d29038f1ce7128954d8a249d1c1532e4f0000011110001";

    let doc_proof = hex::decode(doc_proof_hex).expect("Failed to decode doc proof hex");
    let key_proof = hex::decode(key_proof_hex).expect("Failed to decode key proof hex");

    // Try to parse document proof - should NOT fallback
    let doc_result = parse_det_proof_format(&doc_proof);
    assert!(
        doc_result.is_ok(),
        "Failed to parse document proof: {:?}",
        doc_result.err()
    );

    let doc_nodes = doc_result.unwrap();
    println!(
        "Successfully parsed {} nodes from document proof",
        doc_nodes.len()
    );
    assert!(
        doc_nodes.len() > 5,
        "Expected more than 5 nodes from document proof, got {}",
        doc_nodes.len()
    );

    // Display first few nodes
    for (i, node) in doc_nodes.iter().enumerate().take(5) {
        println!(
            "  Doc node {}: is_left={}, hash={}",
            i,
            node.is_left,
            hex::encode(&node.hash[..8])
        );
    }

    // Try to parse key proof - should NOT fallback
    let key_result = parse_det_proof_format(&key_proof);
    assert!(
        key_result.is_ok(),
        "Failed to parse key proof: {:?}",
        key_result.err()
    );

    let key_nodes = key_result.unwrap();
    println!(
        "\nSuccessfully parsed {} nodes from key proof",
        key_nodes.len()
    );
    assert!(
        key_nodes.len() > 5,
        "Expected more than 5 nodes from key proof, got {}",
        key_nodes.len()
    );

    // Display first few nodes
    for (i, node) in key_nodes.iter().enumerate().take(5) {
        println!(
            "  Key node {}: is_left={}, hash={}",
            i,
            node.is_left,
            hex::encode(&node.hash[..8])
        );
    }
}
